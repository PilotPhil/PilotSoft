## 1.运算符优先级

位置在上者优先级高于下者，由左至右

- 逻辑运算符 NOT 非
- 算术运算符（*, /, %）
- 算术运算符（+, -）
- 相对关联运算符（<, >, <=, >=）
- 逻辑运算符 AND 且
- 逻辑运算符 OR 或
- 赋值运算符

实例：

```c++
!val%2//不正确
```

想法：利用val模以2来判断val的奇偶性，val为偶数时，模运算后余0,为奇数余非零，再取反。

实际上：NOT运算优先级最高，先运行`!val`，除非val为零，其结果都为`false`

应该为

```c++
!(val%2)//正确
```



## 2.指针

```c++
int val=1024;	//定义一个int对象并赋值1024
int * p;		//定义了一个int型的对象的指针
val;			//核估val的值
&val;			//核估val所在的内存地址
p=&val;			//指针对象指向val的内存地址
```

- 要存取一个由指针寻址的对象，需要对该指针进行提领（dereference）操作，也就是取得“位于该指针所在内存地址上”的对象，在指针前使用 * 号。

```c++
*p;//核定p指针所指内存地址上对象的值
```



- 指针可能并不指向任何对象:null指针

```c++
int * p=0;//
```



## 3.传值、传址

### 传值

```c++
#include<iostream>
using namespace std;

void swap(int val1,int val2)
{
    int tem;
    tem=val1;
    val1=val2;
    val2=tem;
}

int main()
{
    int a=1;
	int b=2;
    cout<<"a:"<<a<<"b:"<<b<<endl;
    swap(a,b);//
    cout<<"a:"<<a<<"b:"<<b<<endl;
    
    return 0;
}
```

  - 采用传值的方式，传给swap函数的对象被复制了一份，将实参a、b的分别拷贝给val1、val2，对复制品的更改与原对象a、b之间没有关系。swap完成了对val1、val2的交换，但程序结束后val1、val2被销毁，不会对实参产生影响
  - 调用一个函数时，会在内存中建立一块特殊区域，称为“程序栈（program stack）“，这块特殊区域提供了每个函数参数的存储空间，也提供了函数内定义的局部对象的存储空间，一旦函数执行完，这块内存就会被释放掉


### 传址

```c++
#include<iostream>
using namespace std;

void swap(int &val1,int &val2)//引用传递
{
    int tem;
    tem=val1;
    val1=val2;
    val2=tem;
}

void swap(int *val1,int *val2)//地址传递
{
    int tem;
    tem=*val1;
    *val1=*val2;
    *val2=tem;
}

int main()
{
    int a=1;
	int b=2;
    cout<<"a:"<<a<<"b:"<<b<<endl;
    swap(a,b);//
    cout<<"a:"<<a<<"b:"<<b<<endl;
    
    return 0;
}
```

- 地址传递：把实参的存储地址传送给对应的形参，从而使得形参指针和实参指针指向同一个地址。实际上，传地址依然是实参到形参的拷贝，只不过交换的是两个实参的内存地址，因此，被调用函数中对形参指针所指向的地址中内容的任何改变都会影响到实参。
- 引用传递：没有实参到形参的拷贝，直接将实参a、b传入swap中。以引用为参数，则既可以使得对形参的任何操作都能改变相应的数据，又使得函数调用显得方便、自然。引用传递方式是在函数定义时在形参前面加上引用运算符“&”。传引用，在中间产生的临时对象会记住所有动作，就算函数的栈帧结构全部销毁，并不会影响到引用参数的临时对象

