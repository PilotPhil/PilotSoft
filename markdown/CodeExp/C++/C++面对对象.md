##  C++

### 动态分配内存
```c++
int *p=new int;
int *arr=new int[12];

delete p;
delete []p;
```
- 释放后，将指针置空

```c++
//野指针指向一个已删除的对象或未申请访问受限内存区域的指针。
//与空指针不同，野指针无法通过是否为NULL来判断，只能养成良好编程习惯
int *a=new int;
int *b=new int(3);//定义一int类指针并初始化为3
int *c=new int[5];
delete []c;
c=NULL;
delete b;
b=NULL;
delete a;
a=NULL;//释放完后，将指针置为空，防止野指针
```

### 缺省参数函数

```c++
int myAdd(int x=5,int y=12)
{
	return x+y;
}

myAdd(10,10);
myAdd(5);
myAdd();
```

### 函数重载

```c++
void fun()
{
	cout<<"fun的第一种形态"<<endl;
}
void fun(int x)
{
	cout<<"fun的第二种形态"<<endl;
}
```

### 强制类型转换

```c++
//两种强制转换方式，推荐使用后一种
y=(int)x;
y=int(x);
```

### 面向对象

- 类：将数据的表示和数据的操纵方法组合成一个整体
- 类的实例称为对象
- 类中变量和函数称为成员



- public：修饰的成员在任何地方可访问
- private：修饰的成员只能够在类中或友元函数中访问，无法在类外访问私有成员



- - **不能在类的声明中给任何数据成员进行初始化**
  - 声明类的同时定义对象，是全局对象
  - 使用对象时再定义，是全局对象
  - 不加private、public、protected，默认为私有数据
  - 定义类时，成员函数一般类内声明，类外定义
  - 类的成员函数可以访问类内的任何数据成员
  - **同一类的对象可以相互赋值**



#### C++三大特点：封装、继承、多态

- 封装：对象将私有元素和实现操作的内部细节的结果隐藏起来，并能管理自己的内部状态。外部只能从对象所表示的具体概念、对象提供的服务和对象提供的外部接口来认识对象。
- 继承：避免公用代码的重复开发，减少代码和数据冗余 。通过增强一致性来减少模块间的接口。
- 多态：一个函数完成多个功能

#### 构造函数

- 系统自动调用，不能显式调用

- 一个特殊的成员函数，用于初始化对象

- 每个类必须要有一个构造函数，如果没有，系统会自动生成一个

- 构造函数必须与类同名

- 没有返回值，void也不行

- 一旦用户实现了构造函数，系统默认的构造函数就会被屏蔽

- **构造函数可以重载**

- **若不想写无参的构造函数，将带参的构造函数写成缺省参数**

- ```c++
  class circle
  {
  	int r;
  public:
      circle(int r=0);//带缺省值的构造函数-声明
      ~circle();//析构函数
      void Area()
  };
  
  //成员函数的实现
  circle::circle(int r=0)
  {
      this->r=r;
      cout<<"调用了构造函数"<<endl;
  }
  circle::~circle()
  {
      cout<<"调用了析构函数"<<endl;
  }
  void circle::Area()
  {
      cout<<"面积："<<pi*r*r<<endl;
  }
  
  int main()
  {
      circle c1;
      circle c2(10);
      c1.Area();
      c2.Area();
      
      circle *c3=new circle(20);
      c3->Area();
      delete c3;
  }
  ```

  

#### 析构函数

- 一个特殊的成员函数，执行与构造函数相反的操作，执行一些清理任务，释放空间等。

- 如果类中数据成员没有指针变量，析构函数基本没有用处

- 析构函数与类同名，前面加~

- **没有参数，没有返回值，不能重载，一个类只能有一个析构函数**

- 撤销对象时，系统自动调用析构函数

- ```c++
  class test
  {
    int *a;
  public:
      test(int num=100);
      ~test();
      void myPrint();
  };
  
  //成员函数实现
  test::test(int num)
  {
      a=new int(num);//一指针变量的数据成员指向一块动态申请的内存空间，需要在析构函数中delete
  }
  test::~test()
  {
      delete a;
  }
  void test::myPrint()
  {
      cout<<"*a:"<<*a<<'\t'<<"address of a:"<<a<<endl;
  }
  ```

#### 拷贝构造函数

- 作用：用一个已有的对象来初始化一个被创建的同样对象

- 是一种特殊的构造函数

#### const修饰的成员函数

  - 成员函数可以访问类中的任意数据成员，使用const修饰成员函数，不让它修改数据成员，只读

  - 成员函数的声明和定义后面都要加const

  - **例外：当数据成员前用mutable修饰时，在const修饰的成员函数内也可以修改**

  - ```c++
    class test
    {
      int num;
    public:
        test();
        ~test();
        void change() const;
    };
    
    //实现
    void test::change() const
    {
        cout<<num<<endl;
        //num=121381;//报错-无法修改数据成员
    }
    ```

#### **this指针**

  - 它是成员函数所属对象的指针，指向类的对象

  - 成员函数通过this指针知道自己属于哪一个对象

  - this指针是一个隐含指针，隐含于每一个类的成员函数中。即**哪个对象调用成员函数**，**该this指针就指向哪个对象**

  - ```c++
    test::test(int a)
    {
        this->a=a;//使用this指针成员函数的形参和数据成员可以同名
    }
    ```

  #### 静态数据成员

  - 使用static关键字声明为静态的，称为静态成员

  - 静态成员属于类，而不是某个对象

  - 通过对象使用静态数据成员不规范，应该通过类来使用

  - **无论一个类建立多少对象，静态数据成员只有一个拷贝，是共享的**

  - 静态成员先声明，然后一定要在类外定义（分配内存）不必加static关键字

  - 静态数据成员**不能在类中进行初始化**，因为在**类中不给它分配内存空间**，必须**在类外的其它地方为它提供定义**。 一般在 main()开始之前，类的声明之后的特殊地带为它**提供定义和初始化**。缺省时，静态数据成员的初始值为 0

  - ```c++
    class A {
    public:
    	static int a; //声明但未定义
    };
    int A::a = 3; //定义了静态成员变量，同时初始化。也可以写"int A:a;"，即不给初值，同样可以通过编译
    int main() 
    {
    	A test1,test2;
        
        //通过对象来使用静态数据成员-不规范
        cout<<"test1.a:"<<test1.a<<endl;
        cout<<"test2.a:"<<test2.a<<endl;//静态成员a是共享的，两个都输出3
        
        cout<<A::a;//应当通过类类使用静态数据成员
    	return 0;
    }
    ```

  - 使用场景：

    - 放在构造函数中，统计对象的个数

    - ```c++
      class A
      {
        public:
          static int num_class;
          A();
          ~A();
      };
      
      int A::num_class=0;//静态成员的定义（初始化为0）
      
      A::A()
      {
          num_class++;//每实例化一个对象，num_class自增一
      }
      A::~A()
      {
          
      }
      ```

  - 私有静态数据成员：是私有成员，无法在类外调用，但同样需要在类外定义

#### 静态成员函数

  - 带有static关键字的成员函数
  - 可以使用**类名：：**以及**对象名.**两种方法调用静态成员函数，普通成员函数只能够通过**对象名.**的方式调用
  - 静态成员函数是一个特殊的成员函数。它不属于某一个特定对象
  - 一般而言，静态成员函数访问的都是静态数据成员或者全局变量，不能访问普通数据成员
  - 静态成员函数既可以在类内定义也可以在类内声明类外定义
  - **使用静态成员函数 可以在建立任何对象之前处理静态数据成员**，这是普通成员函数无法实现的功能。

#### 对象成员

- 一个类，类中的一个数据成员是一个对象，这就是对象成员
- 

#### 友元

- 在不放弃私有数据安全性的条件下，使得类外部的可以访问私有成员
- 友元是一扇通向私有成员的后门
- 友元分为：友元函数、友元成员、友元对象

#### 友元函数

- 友元函数**不是当前类的成员函数**，是**独立于当前类的外部函数**，但它**可以访问该类的所有对象的成员**

- 类中**声明**友元函数时，加上关键字**friend**，声明**可放在公有也可放在私有**

- 友元函数可以在类内或类外实现

- 无论友元函数定义在类内还是类外，它都不是一个成员函数

- 友元函数一般带有一个该类的入口参数，通过入口参数传递对象名或者对象指针来使用该对象的成员

- 当一个函数需要**访问多个类时**，友元函数非常有用-普通成员函数只能够访问其类的数据成员

- 友元函数破坏了数据的隐蔽性，降低了程序的可维护性，应谨慎使用

- ```c++
  class test
  {
    int a;
  public:
  	test();
      ~test();
      friend void disp(test &inp);//
  };
  test::test(){a=121381;}
  test::~test(){}
  //类外实现友元函数
  void disp(test &inp)
  {
      cout<<inp.a;//友元函数访问私有数据成员
  }
  
  int main()
  {
      test num;
      disp(num);//调用友元函数,它不是成员函数，不能 用 对象名. 的方式调用
      return 0;
  }
  ```

- 友元函数访问两个类

- ```c++
  class girl;//先声明girl类，因为boy类中要用到girl类
  class boy
  {
  	int num;
  public:
  	boy();
  	~boy();
  	friend void disp(boy &b,girl &g);//girl类中声明友元函数
  };
  class girl
  {
    int num;
  public:
      girl();
      ~girl();
      friend void disp(boy &b,girl &g);//boy类中声明友元函数
  };
  boy::boy(){num=1};
  boy::~boy(){}
  
  girl::girl(){num=0}
  girl::~girl(){}
  
  //友元函数实现
  void disp(boy &b,girl &g)//友元函数必须定义在两个类的下面，否则无法使用
  {
      cout<<"number of boy"<<b.num<<endl;
      cout<<"number of girl"<<g.num<<endl;
  }
  
  int main()
  {
      girl g1;
      boy b1;
      disp(b1,g1);
  }
  ```

  

- 友元成员函数

  - 一个类的成员函数也可以作为另一个类的友元

  - 这种成员函数不仅可以访问自己类中的数据成员，亦可以访问friend声明语句所在的类的私有成员和公有成员。

  - 声明友元函数时，要加上这个成员函数所在类的类名：friend void classa::disp();

  - ```c++
    class girl;//向前引用
    class boy
    {
    	int num;
    public:
    	boy();
    	~boy();
    	void disp(girl &g);//boy类的一个成员函数
    };
    
    class girl
    {
      int num;
    public:
        girl();
        ~girl();
        friend void boy::disp(girl &g);//boy类的成员函数声明为girl类的友元函数
    };
    boy::boy(){num=1};
    boy::~boy(){}
    
    girl::girl(){num=0}
    girl::~girl(){}
    
    //友元函数实现
    void boy::disp(girl &g)//友元函数必须定义在两个类的下面，否则无法使用
    {
        cout<<"number of boy"<<num<<endl;//是boy类的一个成员函数，可以直接访问数据成员
        cout<<"number of girl"<<g.num<<endl;//是girl类的友元函数，通过入口参数访问
    }
    
    int main()
    {
        girl g1;
        boy b1;
        b1.disp(g1);//
    }
    ```

    

#### 友元类---缺省---后期补充

- 一个类也可以作为另一个类的友元

- 友元类的声明方法是在另一个类声明中加入friend修饰

- ```c++
  class A
  {
      //…………
  }
  class B
  {
      friend A;//A是B的友元类，在类A中可以访问类B的数据
      //…………
  }
  ```

#### 运算符重载---缺省---后期补充

#### 继承与派生

- 基类：父类     派生类：子类

- ```c++
  class son:public father
  {
      //………………
  };
  ```

  

- 设计一新类时，继承父类的成员，**减少设计类的冗余开发**，较好的解决了代码重用问题

- 三种派生方式：public、private、protected

- 单继承：派生类只继承了一个基类的特征

- 多继承：多个基类派生出一个派生类

- **public继承：**

  - **基类中私有成员—>派生类中不可访问**
  - **基类中公有成员—>派生类中是公有的**

- **private继承**

  - **基类中私有成员—>派生类中不可访问**

  - **基类中公有成员—>派生类中是私有的**

- **保护成员**
  - 不涉及派生时，**私有成员和保护成员地位一样**，类内可以访问，类外不可访问
  - 将基类中的私有成员声明为保护的，其在派生类中是可用的
  - 公有派生时，**基类中保护成员—>派生类中仍是保护的**
  - 私有派生时，**基类中保护成员—>派生类中是私有的**

- **protected继承**

  - **基类中私有成员—>派生类中不可访问**
  - **基类中公有成员—>派生类中是保护的**

- **总结**

  |      | public派生      | private派生  | protected派生 |
  | :--: | :--------:  | :---------: | :-----------: |
  | 私有 | NULL           | NULL | NULL |
  | 保护 | 保护           | 私有 | 保护 |
  | 公有 | 公有           | 私有 | 保护 |

- 规律总结：

  - 无论什么派生方式，基类中私有成员，在派生类中都不可访问
  - 公有派生，保护依然保护，公有依然公有
  - 私有派生，无论保护还是私有，都变成私有
  - 保护派生，无论保护还是私有，都变成保护

#### 多继承

- 派生类具有多个基类

- ```c++
  class son:public father0,father1,father2
  {
    //……………………  
  };
  ```

- 使用多继承要避免二义性

- ```c++
  class A
  {
  public:
      void print();
  };
  class B
  {
  public:
      void print();
  };
  class C:public A,B
  {
      
  };
  
  int main()
  {
      C test;
      //test.print();//ERROR,会产生二义性
      test.A::print();//对
      test.B::print();//对
  }
  ```

  

#### 派生类的构造函数和析构函数

- 派生类构造函数执行顺序：先基类的构造函数，再派生类的构造函数

- 派生类析构函数执行顺序：先派生类的析构函数，再基类的析构函数

- 派生类构造函数构造规则

- ```c++
   派生类构造函数的一般格式 派生类构造函数名(参数表 0):基类构造函数名(参数表 1) 
   {
       //...... 
   }
    
  class A
  {
      int i;
  public:
      A(int i=0)
      {
          this->i=i;
      }
      ~A(){}
      void print(){};
  };
  
  class B:public A//B公有继承自A
  {
      int j;
  public:
      B(int j=0):A()
      {
          this->j=j;
      }
      ~B(){}
  }
  ```

- 当派生类中含有对象成员时，其构造函数一般形式为

- ```c++
  派生类构造函数名(参数表 0):基类构造函数名(参数表 1), 
  						对象成员名 1(参数表 2),...., 
  						对象成员名 n(参数表 n+1) 
  {
      //...... 
  }
  ```

  

#### 联编

- 静态联编：指联编工作是在程序编译链接阶段进行的，静态联编又称早期联编。静态联编特点：速度快效率高
- 动态联编：动态联编是指编译程序在编译阶段并不能确切地知道将要调用的函数，只有在程序执行时才能确定将要调用 的函数，为此要确切地知道将要调用的函数,要求联编工作在程序运行时进行，这种在程序运行时进行的联编工作 被称为动态联编。
  - C++规定：动态联编是在虚函数的支持下实现的。 
  - 动态联编，编译器在程序运行时才知道这个函数的具体作用 
  - C++中，动态联编必须包括以下方面：
    - 1、成员函数必须声明为 virtual 
    - 2、如果基类中的成员函数声明为虚函数，则派生类中不必再声明 虚函数其实类似于函数指针

#### 虚函数


